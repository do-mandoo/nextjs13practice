// 'use client';
import Link from 'next/link';
import './globals.css';
import Control from './Control';
// import { useEffect, useState } from 'react';

export const metadata = {
  title: 'Web tutorials',
  description: 'Generated by genius jinsol',
};

export default async function RootLayout({ children }) {
  // client
  // const [topics, setTopics] = useState([]);
  // useEffect(() => {
  //   fetch('http://localhost:9999/topics')
  //     .then(res => res.json())
  //     .then(result => {
  //       setTopics(result);
  //     });
  // }, []);

  // topic데이터를 가지고와서 html코드를 동적으로 생성한 다음에,
  // 그 결과를 서버(.next폴더)에 저장해서 최종적인, 정적인 내용만 client로 전송함.

  // 데이터 불러오는 것을 client -> server로 바꾸었을 때 장점
  // 1. 용량이 적어진다(client로 js를 전송하지 않으니까.).
  // 2. 같은 server에 있는 주소라면 굉장히 빠르게 동작이 끝난다.
  // 3. server쪽에서 렌더를 끝내고 전송하기때문에 javascript를 disable해도 데이터가 잘 보여진다(server쪽에서 동적으로 생성한 정적인 내용을 client로 보내기 때문에).

  // server
  // cache issue해결 방법 1.{ next: { revalidate: 0 } } 2. {cache: 'no-store'}
  const res = await fetch(process.env.NEXT_PUBLIC_API_URL + 'topics', { cache: 'no-store' }); //revalidate: 10 => 10초동안 캐시 유지. 10초 후에 캐시 다시 만듦.
  const topics = await res.json();

  return (
    <html>
      <body>
        <h1>
          <Link href='/'>WEB</Link>
        </h1>
        <ol>
          {topics.map(topic => {
            return (
              <li key={topic.id}>
                <Link href={`/read/${topic.id}`}>{topic.title}</Link>
              </li>
            );
          })}
        </ol>
        {children}
        <Control />
      </body>
    </html>
  );
}
